{
  "version": 3,
  "sources": ["../build/_snowpack/pkg/ipaddrjs.js", "../build/isNormalNat.js", "../build/index.js"],
  "sourcesContent": ["var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t\tpath: basedir,\n\t\texports: {},\n\t\trequire: function (path, base) {\n\t\t\treturn commonjsRequire(path, (base === undefined || base === null) ? module.path : base);\n\t\t}\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar ipaddr = createCommonjsModule(function (module) {\n(function (root) {\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 18, 0, 0]), 15],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ],\n            // RFC7534, RFC7535\n            as112: [\n                [new IPv4([192, 175, 48, 0]), 24],\n                [new IPv4([192, 31, 196, 0]), 24],\n            ],\n            // RFC7450\n            amt: [\n                [new IPv4([192, 52, 193, 0]), 24],\n            ],\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv4 address in CIDR notation.\n    ipaddr.IPv4.isValidCIDR = function (string) {\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6666\n            discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC5180\n            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],\n            // RFC7450\n            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],\n            as112v6: [\n                [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],\n                [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48],\n            ],\n            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],\n            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],\n            droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],\n            reserved: [\n                // RFC3849\n                [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],\n                // RFC2928\n                [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32],\n            ],\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // Calls toRFC5952String under the hood.\n        IPv6.prototype.toString = function () {\n            return this.toRFC5952String();\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv6 address in CIDR notation.\n    ipaddr.IPv6.isValidCIDR = function (string) {\n\n        // See note in IPv6.isValid\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = match[1];\n            if (!match[1].endsWith('::')) {\n                addr = addr.slice(0, -1);\n            }\n            addr = expandIPv6(addr + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n    // Checks if the address is valid IP address in CIDR notation\n    ipaddr.isValidCIDR = function (string) {\n        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if ( module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(commonjsGlobal));\n});\n\nvar IPv4 = ipaddr.IPv4;\nexport { IPv4 };\n", "import {IPv4} from \"./_snowpack/pkg/ipaddrjs.js\";\nfunction parseCandidate(line) {\n  let parts;\n  console.log(line);\n  if (line.indexOf(\"a=candidate:\") === 0) {\n    parts = line.substring(12).split(\" \");\n  } else {\n    parts = line.substring(10).split(\" \");\n  }\n  let relatedAddress = null;\n  let relatedPort = null;\n  let tcpType = null;\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case \"raddr\":\n        relatedAddress = parts[i + 1];\n        break;\n      case \"rport\":\n        relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case \"tcptype\":\n        tcpType = parts[i + 1];\n        break;\n      default:\n        break;\n    }\n  }\n  const candidate = {\n    foundation: parts[0],\n    component: parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    port: parseInt(parts[5], 10),\n    type: parts[7],\n    relatedAddress,\n    relatedPort,\n    tcpType\n  };\n  return candidate;\n}\nexport const isNormalNat = () => new Promise((resolve, reject) => {\n  const candidates = {};\n  const pc = new RTCPeerConnection({\n    iceServers: [\n      {urls: \"stun:stun1.l.google.com:19302\"},\n      {urls: \"stun:stun2.l.google.com:19302\"}\n    ]\n  });\n  pc.createDataChannel(\"foo\");\n  pc.onicecandidate = function(e) {\n    if (e.candidate && e.candidate.candidate.indexOf(\"srflx\") !== -1) {\n      const cand = parseCandidate(e.candidate.candidate);\n      const {relatedPort, port, ip} = cand;\n      if (IPv4.isValid(ip)) {\n        if (relatedPort !== null && relatedPort !== void 0) {\n          if (!candidates[relatedPort]) {\n            candidates[relatedPort] = [];\n          }\n          if (port !== null && port !== void 0) {\n            candidates[relatedPort].push(port);\n          }\n        }\n      }\n    } else if (!e.candidate) {\n      if (Object.keys(candidates).length === 1) {\n        const ports = candidates[Object.keys(candidates)[0]];\n        resolve(ports.length === 1);\n      }\n    }\n  };\n  pc.createOffer().then((offer) => pc.setLocalDescription(offer));\n});\n", "import {isNormalNat} from \"./isNormalNat.js\";\n(async () => {\n  const isNN = await isNormalNat();\n  const el = document.querySelector(\".nat\");\n  if (el instanceof HTMLElement) {\n    el.innerText = isNN ? \"Normal NAT\" : \"Symmetric NAT\";\n  }\n})();\n"],
  "mappings": "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",
  "names": []
}
